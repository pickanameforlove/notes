## 词法分析

词法分析采用的技术，编码技术，最小距离矫正技术，超前搜索技术，

**字母表** ：符号的有限集合。

**串** ： 符号的有穷序列

**语言**：串集。属于该语言的串称为该语言的句子。

**串的运算** ： 连接，积（$s^0 = \varepsilon , s^i = s^{i-1}s$）

**语言的运算** ： 和，连接，积，闭包，正闭包

上面定义语言是从字母$\rightarrow$串$\rightarrow$语言，还有一种定义语言的角度，直接从一组定义规则入手，正规式表示的语言称为正规集。

**正规式** $\varepsilon$是正规式，它代表{$\varepsilon$} ;如果r和s都是正规式，它们分别表示语言L(r)和L(s)，那么r|s，rs，r*和r都是正规式，分别表示语言L(r)$\cup$L(s)，L(r)L(s)，(L(r))\*和L(r)。正规式表示的语言叫做正规集。

**转换图**节点是状态，边是接收的字符。

**NFA**：是一个离散数学模型（五元组），包括状态集合S；输入符号集合$\sum$；转换函数$S\times (\sum \cup \{\varepsilon\}) \rightarrow P(S)$；$s_0$作为开始状态；$F\subseteq S$是终态集合。

**转换表**，每个状态占一行，每个输入符号和$\varepsilon$各占一列，表的第i行中符号为a的条目是一个状态集合。

**DFA**在**NFA**的基础上他的转换函数是$S\times \sum \rightarrow S$

$\varepsilon - closure(s)$：从**NFA**的状态s开始只通过$\varepsilon$转换到达的**NFA**状态集合。

$\varepsilon - closure(T)$：从T中某个**NFA**状态s开始只通过$\varepsilon$转换到达的**NFA**状态集合。T是一个状态集。

$move(T,a)$：从 T中某个状态s出发通过标号为a的转换到达的**NFA**状态的集合。

算法要用到上面的三个运算，下图是一个算法的例子。

![image-20201125193548854](./pic/image-20201125193548854.png)

就是一个填表算法，如果在$move$过程中产生了新的状态，添加到左侧。直到左侧没有新添加的状态为止。

**从正规式到NFA**

就是三种运算的画图翻译。

**s|t**：从一个点引出两条边，一条边为s，一条边为t

**st**：三个点形成一条线，第一条边是s，第二条边是t。

**(s)\*** ，自环



**DFA化简**

先将一个**DFA**的状态分为两个子集,一个终态集合和一个非终态集合.

![image-20201125201035639](./pic/image-20201125201035639.png)



## 语法分析

**上下文无关文法**：一个四元组，终结符集合$V_T$，非终结符集合$V_N$，开始符号$S$，产生式集合$P$。

**推导**：把符号串中的非终结符用其产生式右边的串来代替。

**最左推导**：先对左边的非终结符进行处理。

**最右推导**：也是规范推导

**二义性**：对于一个终结符序列，有两种不同的推导方式。

**2型文法**：$A\rightarrow \beta ,A \in V_N,\beta \in (V_N \cup V_T)^*$

**语法分析技术概况**：有自顶向下的分析方法，包括带回溯的（这个是万能的，效率又太低，所以不考虑），无回溯的（递归下降分析法，LL(1)分析法）；有自底向上的分析方法，包括算符优先分析法，LR(0)分析法，SLR(1)分析法，LR(1)分析法，LALR(1)分析法。

**自顶向下分析方法的缺点**：不能处理左递归，回溯，难以报告准确的出错位置，效率低。

**FIRST集**：$FIRST(\alpha) = \{a|\alpha \Rightarrow ^* a..., a\in V_T\}$，如果$\alpha$可以星推出$\varepsilon$时，那么$\varepsilon \in FIRST(\alpha)$.

**LL(1)文法**：任意的$A \rightarrow \alpha|\beta$都满足：1）$FIRST(\alpha) \cap FIRST(\beta)=\emptyset $。2）如果$\beta \Rightarrow ^* \varepsilon$，那么$FIRST(\alpha) \cap FIRST(A)=\emptyset$

**LL(1)文法的性质**：没有公共左因子，不是二义的，不含左递归。

**递归下降的预测分析**：为每一个非终结符写一个分析过程，这些过程可能是递归的。

**归约**：使用产生式左部替代右部的过程。关键技术是寻找到一个可归约串（句柄），一个取巧的方式是找最右推导的逆过程。

**短语**：若$S \Rightarrow ^* \alpha A\delta$且$A \Rightarrow ^* \beta$，则称$\beta$是句型$\alpha \beta \delta$相对于非终结符$A$的短语。

**直接短语**：将上面定义改为 $A\Rightarrow \beta$

**句柄**：最左直接短语。

**算符优先分析法**：给要分析的句型左右两边加上#，最开始将左边的#移到栈里面，然后通过比较栈里面从栈顶向下看第一个终结符$V_1$和输入句型从左向右看的第一个终结符$V_2$比较，如果$V_1 \le V_2$，做移进操作，直到 $V_1>V_2$开始归约栈里面的最左素短语。

**终结符的优先级**：1）如果存在$S\Rightarrow ...ab....$或$S\Rightarrow ...aAb....$说明a的优先级等于b，因为他们是一块儿规约的。2）如果存在$S\Rightarrow ...aA...$并且$A\Rightarrow b|Bb$则说明左边的a优先级小于右边的b ,因为要先完成$b|Bb$的归约，才能最终归约到$S$。3）如果存在$S\Rightarrow ...Ab...$并且$A\Rightarrow a|aB$，则说明左边的a 的优先级大于右边的b的优先级。如果根据上面的规则，推导出两个终结符之间存在两种以上的优先关系，说明文法本身就是二义的。

**优先函数**：将$n*n$的空间复杂度压缩为$2*n$的空间复杂度

**LR(k)分析技术**：L指的是从左向右扫描输入符号；R指的是最右推导的逆过程；k指的是超前读入的符号个数。

**LR(0)分析法**：先进行文法拓广（除了增加.之外还要对文法规定同一个入口），再画拓广文法的NFA，具体规则：若项目i 为$X\rightarrow \alpha .A\beta$。其中A是非终结符，则从i项目画$\varepsilon$弧射向所有$A\rightarrow .\gamma$ 其中$\gamma \in V^*$，然后经过**NFA**确定化，可以得到最后的**DFA**。

**closure** ：首先$I \in closure(I)$,这是一个初值设置，下面是一个拓展的设置，如果$A\rightarrow \alpha.B\beta \in closure(I)$，且$B\rightarrow \eta$是文法G的一个产生式，则项目$B\rightarrow .\eta \in closure(I)$。closure运算就由上面两条规则确定，直到没有新的产生式进来为止。

**goto**：$goto(I,X) = closure(J),J = \{A\rightarrow \alpha X.\beta | A\rightarrow \alpha .X\beta \in I\}$

**LR(0)项目集规范族构造**：这是构建**LR(0)DFA**的另一种直接的方法，文法拓展之后就可以直接运行出项目规范族来了。需要用到**closure**和**goto**运算。算法如下：

```
begin
	I := closure({s' -> s});
	C := {I};
	repeat
		for C 中的每一个状态I和每一个文法符号X
			if goto(I,X)非空且goto(I,X)不在C中
				将状态goto(I,X)加入到C中
	until 不出现新的状态
end
```



