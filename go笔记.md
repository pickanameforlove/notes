此处从函数开始记录，前面的安装，基本数据类型，流程控制就略过去了。



**函数**与**方法**

**GO**函数可以有多个返回值。

**函数**可以作为一种类型，函数类型的区别是参数和返回值的个数和类型

**闭包**是一个匿名函数，重点在于闭包内声明的变量是安全的，可以把闭包内的变量理解为一个类的静态变量。在一个运行过程中，调用多次闭包，这个变量也只是保存一个。

go函数支持两种参数传递：**值传递**和**指针传递**

go函数支持**defer**语句，当函数执行到最后时（return 语句执行之前），这些defer语句会按照逆序执行。

错误处理机制：**panic**，**error**和**recover**

复合数据类型：**数组**，**切片**和**映射**

**包**：为了简化大型软件设计和维护的工作，实际上包是函数和数据的集合。

**命名空间**：一个包里面的所有的函数变量就是一个命名空间。

go语言的包特性：1）所有导入的包必须在每个文件的开头显示声明。2）禁止包的环状依赖，包的依赖关系是一个有向无环图；每个包都可以被独立编译，甚至可以并发编译；2）编译后包的目标文件不仅记录包本身的导出信息，同时还记录了包的依赖关系。

**标签**：结构体中的字段不仅有名字与类型，还有一个可选的附属于字段的**标签**，它的值是一段字符串，标签内容只有**reflect**包可以获取。

```go
func refTag(tt TagType, ix int)
{
	ttType := reflect.TypeOf(tt);//这可以获取变量的正确类型，如果变量是一个结构体类型，就可以通过Field来索引结构体的字段。
	ixField := ttType.Field(ix);
	fmt.Printf("%v\n",ix.Field.Tag);
}
```

**方法**：是指定了接收者的函数。

go语言可以利用嵌入一个匿名结构体，来实现继承。

**接口**：结构体实现了接口的方法，便视为实现了该接口

**反射**：从实例得到所属的类型的信息。可以使用reflect包来操作。

**并发不是并行**

go内部执行以goroutine为一个单位，go语言针对其实现了一个逻辑处理器，这个逻辑处理器和物理处理器绑定在一起，并实现一些调度算法。

go语言在语言级别支持轻量级线程叫goroutine。

**runtime.Gosched()**表示让CPU把时间片让给别人。

**并发编程的难度在于协调**

**select**语句最大的一个限制是，每个case语句里必须是一个IO操作。

**一切皆文件**：都可以使用打开$\rightarrow$读写$\rightarrow$关闭的模式来操作。

